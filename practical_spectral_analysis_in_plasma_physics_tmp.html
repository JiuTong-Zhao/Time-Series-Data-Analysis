<!DOCTYPE html>
<html>
<head>
<title>practical_spectral_analysis_in_plasma_physics.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Practical Spectral Analysis in Plasma Physics</title>
</head>
<body>
</body></html><h2 id="time-series-and-signals-in-physical-systems">Time Series and Signals in Physical Systems</h2>
<p>In physics and engineering, we often deal with <strong>signals</strong> – functions that vary over time and represent some physical quantity. A signal can be any measurable quantity that changes with time: for example, an audio waveform, the voltage output of a sensor, or the magnetic field measured in a plasma experiment. When we record such a quantity at successive points in time, we get a <strong>time series</strong>.</p>
<p>Many familiar phenomena are naturally described as time series, including:</p>
<ul>
<li><strong>Meteorology:</strong> e.g. El-Nino Enso</li>
</ul>
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure1_el_nino_enso.png" alt="Multivariate ENSO Index (MEI)" width="400">
<ul>
<li><strong>Geophysics:</strong> e.g. Seismic Waves</li>
</ul>
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure2_seismic_waves.jpg" alt="drawing" width="400">
<ul>
<li><strong>Solar Physics:</strong> e.g. Sunspot Number</li>
</ul>
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure3_sunspot_number.jpg" alt="Adopted from https://solarscience.msfc.nasa.gov/SunspotCycle.shtml" width="400">
<!-- ![](figure2_seismic_waves.jpg) -->
<!-- ![](figure1_el_nino_enso.png){width=60} -->
<p>Each of these is a time-domain description: we have a quantity (amplitude, voltage, etc.) <strong>as a function of time</strong>.</p>
<p>Understanding the time-domain behavior of a system is important. However, it is often hard to tell <strong>what underlying patterns or oscillations</strong> are present. This is where <strong>spectral analysis</strong> becomes useful.</p>
<h2 id="why-do-we-need-spectral-analysis">Why Do We Need Spectral Analysis?</h2>
<p><strong>Spectral analysis</strong> examines a signal in the frequency domain instead of the time domain.</p>
<p>Imagine listening to an orchestra. The audio signal is a complex waveform. But your brain can distinguish individual notes — essentially doing spectral analysis!</p>
<p>In <strong>plasma physics</strong>, spectral analysis helps resolve the basic properties of wave (e.g., amplitutde, compressibility) by revealing dominant frequencies in electric/magnetic field fluctuations.</p>
<p>Spectral analysis helps to:</p>
<ol>
<li><strong>Identify dominant frequencies</strong> in a signal.</li>
<li><strong>Detect multiple overlapping processes</strong>.</li>
<li><strong>Understand system behavior</strong> through resonance.</li>
<li><strong>Filter or reduce noise</strong>.</li>
</ol>
<h2 id="nyquist-frequency-and-aliasing">Nyquist Frequency and Aliasing</h2>
<blockquote>
<h3 id="nyquist%E2%80%93shannon-sampling-theorem">Nyquist–Shannon Sampling Theorem:</h3>
<p>A band-limited continuous-time signal $x(t)$ containing no frequency components higher than $f_{max}$,  can be perfectly reconstructed from its samples if it is sampled at a rate:
$
\begin{align}
f_s \ge 2 f_{max}
\end{align}
$</p>
</blockquote>
<p>Correspondingly, we can define the Nyquist frequency as $f_s/2$ to be the maximum measurable frequency of the signal. Any signal above this frequency can not be well measured and will also affect the frequency spectrum below $f_s/2$. The latter effect is also called <em><strong>Aliasing</strong></em>.</p>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_aliasing.png" alt="Adopted from https://solarscience.msfc.nasa.gov/SunspotCycle.shtml" width="400">
</p>
<p>It can be seen that the downsampled signal still represents a periodicity with a period that longer than the real signal period, which means the low-frequency spectrum is also influenced.</p>
<p>To avoid that, you need to apply a low-pass filter with the Nyquist frequency (e.g., <em>scipy.signal.decimate</em>) to clean the high frequency component. This procedure can be implemented when the high cadence measurements (e.g., 128 Hz ~ kHz magnetic field measurement) are available but the data processing is over time consuming. If you already get the downsampled signal, unfortunately, you are no longer able to distinguish the real low frequency signal or the aliased one.</p>
<h2 id="time-vs-frequency-domain">Time vs. Frequency Domain</h2>
<p>The <strong>frequency domain</strong> describes <strong>what frequencies a signal contains</strong>, not how it changes over time.</p>
<p>Any signal $x(t)$ can be decomposed into sinusoidal components via the <strong>Continuous Fourier Transform</strong>:</p>
<p>$$
\begin{align}
X(f) = \int_{-\infty}^{+\infty} x(t) e^{-2\pi i f t} , dt
\end{align}
$$</p>
<p>However, in the real application, the signal is always discrete and finite, and <strong>Discrete Fourier Transform</strong> is actually applied:</p>
<p>$$
\begin{align}
X[f_k] = \sum_{n=0}^N x[t_n] e^{-2\pi i f_k t} , \Delta  t
\end{align}
$$</p>
<p>Idealy, accroding to the periodicity of $e^{-2\pi i ft}$, the DFT actually calculate the CFT coefficients by extending the original series along and anti-along the time axis.</p>
<p>$$
\begin{align}
X[f_k] &amp; = \lim_{M\rightarrow+\infty} \frac{1}{M} \sum_{n=-(M-1)\times N}^{M \times N} x[t_n] e^{-2\pi i f_k t} , \Delta  t\
&amp;\approx \int_{-\infty}^{+\infty} x_{ext}[t_n] , d t
\end{align}
$$</p>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_dft.png" alt="An example of DFT." width="100%">
</p>
<p align="center">
An example of DFT
</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Generate a sinuous signal</span>
omega = <span class="hljs-number">2</span> * np.pi * <span class="hljs-number">5</span>
time = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">200</span>)
signal = np.sin(omega * time)

dt = time[<span class="hljs-number">1</span>] - time[<span class="hljs-number">0</span>]
<span class="hljs-comment"># Complex coefficient</span>
coefs = np.fft.fft(signal)
<span class="hljs-comment"># Corresponding frequency with both zero, positive, and negative frequency</span>
freqs = np.fft.fftfreq(coefs.size, dt)
</div></code></pre>
<p>Given a window length n and a sample spacing dt (i.e., <em>np.fft.fftfreq(n, dt)</em>):</p>
<pre class="hljs"><code><div>f = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ...,   n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>,     -n/<span class="hljs-number">2</span>, ..., <span class="hljs-number">-1</span>] / (dt * n)   <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> even
f = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ..., (n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>, -(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>, ..., <span class="hljs-number">-1</span>] / (dt * n)   <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> odd
</div></code></pre>
<p>So, the sinuous waves can still be well-decomposited by DFT.</p>
<pre class="hljs"><code><div>f[::n // <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ...,   n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>] / (dt * n)   <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> even
f[::n // <span class="hljs-number">2</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ..., (n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>] / (dt * n)   <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> odd
</div></code></pre>
<p>For an even signal length <em>n</em>, the Nyquist Frequency and corresponding coefficient is actually ignored. So, it is suggested to use <em>numpy.fft.rfft (rfftfreq)</em> instead of <em>numpy.fft.fft (fftfreq)</em>, which intrinsically truncate the output coefficients and frequencies.</p>
<pre class="hljs"><code><div>coefs = np.fft.rfft(signal)
freqs = np.fft.rfftfreq(coefs.size, dt)
</div></code></pre>
<h2 id="frequency-resolution">Frequency Resolution</h2>
<p>Assuming you already get a prepared signal, a common way to extract the periodicity from the signal is <em>DFT</em>. By this transformation, you can perfectly convert the signal to the frequency domain without any loss of the physical information.</p>
<p>The yield spectrum contains the wave coefficient at the frequency of</p>
<p>$
\begin{align}
\frac{i}{N}\frac{f_s}{2}=\frac{i/2}{N\Delta t}=\frac{i/2}{\Delta T}
\end{align}
$</p>
<p>where $i=1,2,...,N$ and $\Delta T=N\Delta t$ is the total duration of the signal.</p>
<h3 id="periodic-extensions">Periodic Extensions</h3>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_dft_periodic_extensions.png" alt="An example of DFT." width="100%">
</p>
<h3 id="windowing-effect">Windowing Effect</h3>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_dft_spectral_leakage_window.png" alt="An example of DFT." width="100%">
</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Without Normalization</span>
signal *= np.hanning(signal.size)
<span class="hljs-comment"># With Normalization</span>
signal *= np.hanning(signal.size) * np.sqrt(<span class="hljs-number">8</span> / <span class="hljs-number">3</span>)
</div></code></pre>
<h3 id="fence-effect">Fence Effect</h3>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_dft_picket_fence_effect.png" alt="An example of DFT." width="100%">
</p>
<h3 id="zero-padding">Zero-Padding</h3>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_dft_spectral_leakage_zero_padding.png" alt="An example of DFT." width="100%">
</p>
<pre class="hljs"><code><div>dt = time[<span class="hljs-number">1</span>] - time[<span class="hljs-number">0</span>]
n = signal.size

N_PADDING = <span class="hljs-number">29</span>

coefs = np.fft.fft(signal, n = signal.size + N_PADDING)
freqs = np.fft.fftfreq(coefs.size, dt)
</div></code></pre>
<h2 id="parsevals-theorem-and-energy-conservation">Parseval's Theorem and Energy Conservation</h2>
<blockquote>
<p><strong>Parseval's Theorem for CFT:</strong>
$
\begin{align}
\int_{-\infty}^\infty x^2(t), dt = \int_{-\infty}^\infty X^2(f), df
\end{align}
$</p>
</blockquote>
<blockquote>
<p><strong>Parseval's Theorem for DFT:</strong>
$
\begin{align}
\sum_{n=0}^{N-1}|x(t_n)|^2 = \frac{1}{N}\sum_{k=0}^{N-1}|X(f_k)|^2
\end{align}
$</p>
</blockquote>
<p>In the physical world, the square power of the ampltitude often refers to some kind of <em><strong>energy</strong></em> or <em><strong>power</strong></em>. For example, the square of the displacement ($x$) of a spring, $x^2$ is propotional to the elastic potential energy ($kx^2/2$, where $k$ describes the stiffness). In plasma physics, electromagnetic field contains the energy density ($u$) written as</p>
<p>$
\begin{align}
u=u_E + u_B=\frac{1}{2}(\varepsilon_0 \mathit{E}^2 + \frac{1}{\mu_0}\mathit{B}^2)
\end{align}
$</p>
<p>In this case, the <em><strong>energy</strong></em> of the signal naturally linked with the <em><strong>energy</strong></em> of the electromagnetic field. Nevertheless, the energy of a signal is an extensive property as it linearly increases with the length of the sample. In the ordinary investigation, the signal energy is always further converted as signal <em><strong>power</strong></em>, which is an intensive property that describe the amplitude and is independent of signal length. The defition of power, <em>P</em>, can be written as:</p>
<p>$
\begin{align}
P&amp;= \frac{1}{T}\int_{-T/2}^{T/2}|x(t)|^2 \mathrm{d}t\
\end{align}
$</p>
<p>or
$
\begin{align}
P&amp;=\frac{1}{N\Delta t}\sum_{n=0}^{N-1}|x(t_n)|^2 \Delta t\
&amp;=\frac{1}{N^2\Delta f}\sum_{k=0}^{N-1}|X(f_k)|^2 \Delta f \
&amp;=\sum_{k=0}^{N-1} \boxed{\frac{1}{Nf_s} |X(f_k)|^2}, \Delta f
\end{align}
$</p>
<p>for DFT. Considering that DFT yields both positive and negative frequency, we typically fold the DFT result. Naturally, the definition of <em>power spectral density (PSD)</em> is given as:</p>
<p>$
\begin{align}
&amp;\sum_{k=0}^{N-1} PSD(f_k) \Delta f =\
\mathrm{For\ Even \ }N:\ &amp;\Delta f \left[PSD(f_0) + \sum_{k=1}^{{(N-1)}/{2}} 2\cdot PSD(f_k) + PSD(f_{N/2})\right]\
\mathrm{For\ Odd \ }N:\ &amp;\Delta f \left[PSD(f_0) + \sum_{k=1}^{{(N-1)}/{2}} 2\cdot PSD(f_k)\right]
\end{align}
$</p>
<pre class="hljs"><code><div>N = coef.size
FS = <span class="hljs-number">1</span> / dt
psd = (np.abs(coef) ** <span class="hljs-number">2</span>) / (N * FS)

<span class="hljs-keyword">if</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
    psd[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>] *= <span class="hljs-number">2</span>
<span class="hljs-keyword">else</span>:
    psd[<span class="hljs-number">1</span>:] *= <span class="hljs-number">2</span>
</div></code></pre>
<p align="center">
<img src="file:///home/jtzhao/Code/personal_code/guide_to_wave_analysis/figure_fft_normalization.png" alt="An example of DFT." width="100%">
</p>
<p>$
\begin{align}
|X(f_k)| \propto f_s \cdot T
\end{align}
$</p>
<p>According to the lineairty of $\mathcal{F}$, $X(f_k)$ should also be propotional to the signal ampltitude. Easily catch that the coefficient at the exact wave frequency has the form of</p>
<p>$
\begin{align}
|X(f_k)| = \frac{1}{2}A(f_k) \cdot f_s \cdot T
\end{align}
$</p>
<p>$1/2$ in this equation arises from the fact that $\int_0^{2\pi}\mathrm{sin^2}x \mathrm{d}x=1/2$.</p>
<details>
<summary>Python Implication of Power Spectral Density Calculation</summary>
<code>
</code>
</details>
<h2 id="white-noise">White Noise</h2>
<h2 id="welch-method-scipysignalwelch">Welch Method [<em>scipy.signal.welch</em>]</h2>
<p>Welch proposed that the averaging the power spectral density instead of the coefficient can largely reduce the flutuation levels of the spectrum. Therefore, we may just get a.</p>
<h2 id="lomb-scargle-periodigram-scipysignallombscargle">Lomb Scargle Periodigram [<em>scipy.signal.lombscargle</em>]</h2>
<h2 id="empirical-mode-decomposition">Empirical Mode Decomposition</h2>
<h2 id="python-example-time--and-frequency-domain-representations">Python Example: Time- and Frequency-Domain Representations</h2>
<p>Let’s simulate a signal composed of two sine waves (5 Hz and 20 Hz), and then compute its spectrum.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># Sampling parameters</span>
Fs = <span class="hljs-number">1000</span>  <span class="hljs-comment"># Sampling frequency (Hz)</span>
t = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>/Fs)

<span class="hljs-comment"># Time-domain signal: 5 Hz + 20 Hz</span>
signal = np.sin(<span class="hljs-number">2</span>*np.pi*<span class="hljs-number">5</span>*t) + <span class="hljs-number">0.5</span>*np.sin(<span class="hljs-number">2</span>*np.pi*<span class="hljs-number">20</span>*t)

<span class="hljs-comment"># FFT</span>
fft_vals = np.fft.fft(signal)
freqs = np.fft.fftfreq(len(signal), <span class="hljs-number">1.0</span>/Fs)

<span class="hljs-comment"># Only positive frequencies</span>
pos_mask = freqs &gt;= <span class="hljs-number">0</span>
freqs = freqs[pos_mask]
fft_mag = np.abs(fft_vals)[pos_mask]

<span class="hljs-comment"># Plot</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>))

plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)
plt.plot(t, signal)
plt.title(<span class="hljs-string">"Time Domain"</span>)
plt.xlabel(<span class="hljs-string">"Time [s]"</span>)
plt.ylabel(<span class="hljs-string">"Amplitude"</span>)

plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
plt.stem(freqs, fft_mag, basefmt=<span class="hljs-string">" "</span>)
plt.xlim(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>)
plt.title(<span class="hljs-string">"Frequency Domain"</span>)
plt.xlabel(<span class="hljs-string">"Frequency [Hz]"</span>)
plt.ylabel(<span class="hljs-string">"Magnitude"</span>)

plt.tight_layout()
plt.show()
</div></code></pre>
<p>This code creates:</p>
<ul>
<li>A time-domain signal with 5 Hz and 20 Hz components.</li>
<li>Its frequency-domain representation using FFT.</li>
<li>Clear spectral peaks at 5 Hz and 20 Hz.</li>
</ul>
<h2 id="summary">Summary</h2>
<ul>
<li>Time series are signals recorded over time.</li>
<li>Spectral analysis transforms these into the frequency domain.</li>
<li>This reveals hidden structure (e.g. wave modes in plasmas).</li>
<li>Python and FFT make this analysis practical and efficient.</li>
</ul>
<p>Next, we will explore the <strong>mathematical foundation of the Fourier transform</strong> and how to apply it to real-world signals.</p>


</body>
</html>
